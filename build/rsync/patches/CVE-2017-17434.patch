The daemon in rsync 3.1.2, and 3.1.3-development before 2017-11-03, does
not check for fnamecmp filenames in the daemon_filter_list data structure
(in the recv_files function in receiver.c) and also does not apply the
sanitize_paths protection mechanism to pathnames found in "xname follows"
strings (in the read_ndx_and_attrs function in rsync.c), which allows
remote attackers to bypass intended access restrictions.

diff -pruN '--exclude=*.orig' rsync-3.1.2~/receiver.c rsync-3.1.2/receiver.c
--- rsync-3.1.2~/receiver.c	2017-12-07 21:07:12.120100762 +0000
+++ rsync-3.1.2/receiver.c	2017-12-07 21:07:12.147732531 +0000
@@ -728,7 +728,7 @@ int recv_files(int f_in, int f_out, char
 				break;
 			}
 			if (!fnamecmp || (daemon_filter_list.head
-			  && check_filter(&daemon_filter_list, FLOG, fname, 0) < 0)) {
+			  && check_filter(&daemon_filter_list, FLOG, fnamecmp, 0) < 0)) {
 				fnamecmp = fname;
 				fnamecmp_type = FNAMECMP_FNAME;
 			}
diff -pruN '--exclude=*.orig' rsync-3.1.2~/rsync.c rsync-3.1.2/rsync.c
--- rsync-3.1.2~/rsync.c	2015-08-08 21:47:03.000000000 +0000
+++ rsync-3.1.2/rsync.c	2017-12-07 21:07:12.147937649 +0000
@@ -49,6 +49,7 @@ extern int flist_eof;
 extern int file_old_total;
 extern int keep_dirlinks;
 extern int make_backups;
+extern int sanitize_paths;
 extern struct file_list *cur_flist, *first_flist, *dir_flist;
 extern struct chmod_mode_struct *daemon_chmod_modes;
 #ifdef ICONV_OPTION
@@ -396,6 +397,11 @@ int read_ndx_and_attrs(int f_in, int f_o
 	if (iflags & ITEM_XNAME_FOLLOWS) {
 		if ((len = read_vstring(f_in, buf, MAXPATHLEN)) < 0)
 			exit_cleanup(RERR_PROTOCOL);
+
+		if (sanitize_paths) {
+			sanitize_path(buf, buf, "", 0, SP_DEFAULT);
+			len = strlen(buf);
+		}
 	} else {
 		*buf = '\0';
 		len = -1;x
